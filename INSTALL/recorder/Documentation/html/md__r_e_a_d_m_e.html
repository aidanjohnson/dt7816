<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DT7816_Recorder: ArduinoRingBuffer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DT7816_Recorder
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ArduinoRingBuffer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a simple ring (FIFO) buffer library for the Arduino. It is written in vanilla C, and can easily be modified to work with other platforms. It can buffer any fixed size object (ints, floats, structs, etc...).</p>
<h2>Project History</h2>
<p>I needed a way to buffer sensor events for a group engineering IOT project that I was working on at Cornell. We needed to record changes in IR trip wires that happened in ms timeframes, and tight loop polling was not working. We needed interrupts and a buffering library. I couldn't find any suitable Arduino Libraries that could buffer any sized object, so I wrote my own.</p>
<p>I decided to give object oriented programming a shot using only C (no C++) with this library, of course, it still compiles with C++ compilers such as in the Arduino IDE. Using C structs and function pointers, the library creates <a class="el" href="struct_ring_buf.html">RingBuf</a> objects that are complete with their own methods and attributes. Note that every method (except constructor), takes a <code><a class="el" href="struct_ring_buf.html">RingBuf</a> *self</code> pointer. This is the equivalent of the <code>this</code> pointer in C++, but the C++ compiler automatically passes it behind the scenes. For this library, you must manually pass a the <code><a class="el" href="struct_ring_buf.html">RingBuf</a> *self</code> pointer as the first argument, like this:</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">int foo = 1234;</div><div class="line">RingBuf *buf = RingBuf_new(sizeof(int), 20);</div><div class="line">buf-&gt;add(buf, &amp;foo);</div></div><!-- fragment --><h2>What about C++ templates?</h2>
<p>I recently created a C++ alternative to this library that utilizes the power of C++ templates, now you can perform deep copies of objects. Check it out: <a href="https://github.com/wizard97/Embedded_RingBuf_CPP">C++ alternative library</a>.</p>
<h2>Use Cases</h2>
<p>A ring buffer is used when passing asynchronous io between two threads. In the case of the Arduino, it is very useful for buffering data in an interrupt routine that is later processed in your <code>void loop()</code>.</p>
<h2>Supported Platforms</h2>
<p>The library currently supports:</p><ul>
<li>AVR</li>
<li>ESP8266</li>
</ul>
<h2>Install</h2>
<p>This library is now availible in the Arduino Library Manager, directly in the IDE. Go to <code>Sketch &gt; Include Library &gt; Manage Libraries</code> and search for <code><a class="el" href="struct_ring_buf.html">RingBuf</a></code>.</p>
<p>To manually install this library, download this file as a zip, and extract the resulting folder into your Arduino Libraries folder. <a href="https://www.arduino.cc/en/Guide/Libraries">Installing an Arduino Library</a>.</p>
<h2>Examples</h2>
<p>Look at the examples folder for several examples.</p>
<h2>Contributing</h2>
<p>If you find this Arduino library helpful, click the Star button, and you will make my day.</p>
<p>Feel free to improve this library. Fork it, make your changes, then submit a pull request!</p>
<h2>API</h2>
<h3>Constructor</h3>
<div class="fragment"><div class="line">{c++}</div><div class="line">RingBuf *RingBuf_new(int size, int len);</div></div><!-- fragment --><p>Creates a new <a class="el" href="struct_ring_buf.html">RingBuf</a> object of len elements that are size bytes each. A pointer to the new <a class="el" href="struct_ring_buf.html">RingBuf</a> object is returned on success. On failure (lack of memory), a null pointer is returned. This would be the equivalent of <code>new <a class="el" href="struct_ring_buf.html">RingBuf(int size, int len)</a></code> in C++.</p>
<h3>Deconstructor</h3>
<div class="fragment"><div class="line">{c++}</div><div class="line">int RingBuf_delete(RingBuf *self);</div></div><!-- fragment --><p>Deletes the <a class="el" href="struct_ring_buf.html">RingBuf</a>, and frees up all the memory associated with it.</p>
<h2>Methods</h2>
<h3>add()</h3>
<div class="fragment"><div class="line">{c++}</div><div class="line">int add(RingBuf *self, void *object);</div></div><!-- fragment --><p>Append an element to the buffer, where object is a pointer to object you wish to append. Returns -1 on a full buffer. On success, returns the position (index) in the buffer where the element was added.</p>
<h3>peek()</h3>
<div class="fragment"><div class="line">{c++}</div><div class="line">void *peek(RingBuf *self, unsigned int num);</div></div><!-- fragment --><p>Peek at the num'th element in the buffer. Returns a void pointer to the location of the num'th element. If num is out of bounds or the num'th element is empty, a NULL pointer is returned. Cast the result of this call into a pointer of whatever type you are storing in the buffer. Note that this gives you direct memory access to the location of the num'th element in the buffer, allowing you to directly edit elements in the buffer. Note that while all of <a class="el" href="struct_ring_buf.html">RingBuf</a>'s public methods are thread safe (including this one), directly using the pointer returned from this method is not thread safe. If there is a possibility an interrupt could fire and remove/modify the item pointed to by the returned pointer, disable interrupts first with <code>noInterrupts()</code>, do whatever you need to do with the pointer, then you can reenable interrupts by calling <code>interrupts()</code>.</p>
<h3>pull()</h3>
<div class="fragment"><div class="line">{c++}</div><div class="line">void *pull(RingBuf *self, void *object);</div></div><!-- fragment --><p>Pull the first element out of the buffer. The first element is copied into the location pointed to by object. Returns a NULL pointer if the buffer is empty, otherwise returns object.</p>
<p>### numElements() </p><div class="fragment"><div class="line">{c++}</div><div class="line">unsigned int numElements(RingBuf *self);</div></div><!-- fragment --><p>Returns number of elements in buffer.</p>
<p>### isFull() </p><div class="fragment"><div class="line">{c++}</div><div class="line">bool isFull(RingBuf *self);</div></div><!-- fragment --><p>Returns true if buffer is full, otherwise false.</p>
<h3>isEmpty()</h3>
<div class="fragment"><div class="line">{c++}</div><div class="line">bool isEmpty(RingBuf *self);</div></div><!-- fragment --><p>Returns true if buffer is empty, false otherwise.</p>
<h2>License</h2>
<p>This library is open-source, and licensed under the <a href="http://opensource.org/licenses/MIT">MIT license</a>. Do whatever you like with it, but contributions are appreciated. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
